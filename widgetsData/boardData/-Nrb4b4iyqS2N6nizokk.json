{
  "addCellHeaderTemplate": true,
  "addCustomComputedProperty": true,
  "addCustomComputedPropertyForLeftHeaders": false,
  "addCustomComputedPropertyForTopHeaders": false,
  "allowUserSpecificLeftHeaders": false,
  "allowUserSpecificTopHeaders": false,
  "blankColumnDisplayName": "",
  "blankRowDisplayName": "",
  "blockDragging": false,
  "blockHorizontalDragging": false,
  "blockVerticalDragging": false,
  "cardBackgroundColorCoding": " if (item.estimatedProductionPerDay > item.actualProductionPerDay){\r\n\r\n     return 'light-red'\r\n\r\n }\r\n \r\n else {\r\n       return 'pink';  \r\n }\r\n \r\n \r\n\r\n",
  "cardClassBindings": "",
  "cellBackgroundColorCoding": "\r\nif(100 >= getSumOfProperty(headerX, headerY, 'qtytoMfg')) {\r\n    //return '#D5FFC4'\r\n    return '#fff'\r\n} else {\r\n    return '#ffb9b9'\r\n\r\n    \r\n}\r\n",
  "cellHeaderTemplate": "\r\n  <div>\r\n    <div :style=\"{\r\n      borderTop: '4px solid ' + (getSumOfProperty(headerX, headerY, 'totalEstimatedHours') > 40 ? 'red' : 'blue'),\r\n      width: (getSumOfProperty(headerX, headerY, 'totalEstimatedHours') / 40 * 100 > 100 ? 100 : getSumOfProperty(headerX, headerY, 'totalEstimatedHours') / 40 * 100) + '%'\r\n    }\">\r\n      <!-- Empty div for the line -->\r\n    </div>\r\n    <div\r\n    style=\"font-size:10px\"\r\n    >\r\n      {{ getSumOfProperty(headerX, headerY, 'totalEstimatedHours') }} / 40\r\n   \r\n   ({{ (getSumOfProperty(headerX, headerY, 'totalEstimatedHours') / 40 * 100).toFixed(2) }}%)\r\n    </div>\r\n  </div>",
  "customComputedProperty": "function extendSchedule(tasks, scheduleWeeks) {\r\n  const extendedSchedule = [];\r\n  let currentWeekIndex = 0;\r\n\r\n  // Helper function to get the next week index\r\n  const getNextWeekIndex = (currentIndex) => (currentIndex + 1) % scheduleWeeks.length;\r\n\r\n  // Find initial week index\r\n  const findInitialWeekIndex = (weekScheduled) => scheduleWeeks.findIndex(week => week.name == weekScheduled);\r\n\r\n  tasks.forEach(task => {\r\n    //console.log(task)\r\n    let remainingHours = task.totalEstimatedHours; // Changed to totalEstimatedHours\r\n    //console.log(task.$weekScheduled$display)\r\n    currentWeekIndex = findInitialWeekIndex(task.$weekScheduled$display);\r\n    let sequenceNumber = 0; // Start sequence number for appending to rowKey\r\n\r\n    while (remainingHours > 0) {\r\n      const currentWeek = scheduleWeeks[currentWeekIndex];\r\n      // console.log(currentWeek, 'current week', currentWeekIndex)\r\n      // console.log(remainingHours,currentWeek?.availableCapacity)\r\n      const hoursForThisWeek = Math.min(remainingHours, currentWeek?.availableCapacity);\r\n\r\n      // console.log(hoursForThisWeek)\r\n      \r\n      remainingHours -= hoursForThisWeek;\r\n\r\n      extendedSchedule.push({\r\n        ...task,\r\n        sequenceNumber,\r\n        rowKey: task.rowKey + (sequenceNumber > 0 ? `-${sequenceNumber}` : ''), // Append sequence number to rowKey\r\n        weekScheduled: currentWeek?.rowKey, // Set to the rowKey from the scheduleWeeks array\r\n        '$weekScheduled$display': currentWeek?.name, // Set to the name of the week\r\n        totalEstimatedHours: hoursForThisWeek,\r\n        mainTask: sequenceNumber < 1 ? true : false,\r\n        part: task.$part$display,\r\n      });\r\n      \r\n\r\n      if (remainingHours > 0) {\r\n        currentWeekIndex = getNextWeekIndex(currentWeekIndex);\r\n        sequenceNumber++; // Increment sequence number for the next rowKey if needed\r\n      }\r\n    }\r\n  });\r\n\r\n  return extendedSchedule;\r\n}\r\n\r\n// ScheduleWeeks data (complete dataset)\r\nconst scheduleWeeksData = $getGrid('scheduleWeeks')\r\n\r\n// Example tasks data (from opportunityLines)\r\nconst tasksData = $getGrid('opportunityLines').filter(task => task.totalEstimatedHours > 0);\r\n\r\n\r\nconst newSchedule = extendSchedule(tasksData, scheduleWeeksData);\r\nconsole.log('got new schedule')\r\nconsole.table(newSchedule)\r\n\r\nreturn newSchedule",
  "customComputedPropertyForLeftHeaders": "",
  "customComputedPropertyForTopHeaders": "",
  "customComputedPropertyForTopHeadersDataSource": {
    "label": "Computed > generateDateHeaders",
    "value": {
      "expression": "generateDateHeaders",
      "type": "computed"
    }
  },
  "editCardFunction": "",
  "filter": "{\"condition\":\"AND\",\"rules\":[{\"andOr\":\"\",\"key\":\"name\",\"operator\":\"contains\",\"value\":null,\"name\":\"Name\",\"expression\":false,\"hidden\":false}]}",
  "functionForMatchingToCustomLeftHeaders": "",
  "functionForMatchingToCustomTopHeaders": "const headerTimestamp = moment(customHeader.value);\nconst scheduledStart = moment(rowData.scheduledStart);\nreturn headerTimestamp.isSame(scheduledStart, 'day');",
  "itemsStorage": "opportunityLines",
  "laneCol": "weekScheduled",
  "lanesStorage": "opportunityLines",
  "leftLaneCol": "part",
  "onChangeScript": "// ScheduleWeeks data (complete dataset as per your scenario)\r\nconst scheduleWeeks = $getGrid('scheduleWeeks');\r\n\r\n// Extract the total estimated hours from the main item\r\nconst hours = item.totalEstimatedHours;\r\n\r\n// Find the new starting week index based on headerX, which is now the week name\r\nconst newWeekIndex = scheduleWeeks.findIndex(week => week.name === headerX);\r\nif (newWeekIndex === -1) {\r\n  console.error('Week not found:', headerX);\r\n  return;  // Early exit if the week isn't found\r\n}\r\n\r\n// Calculate the distribution of hours across the new weeks\r\nlet remainingHours = hours;\r\nlet currentWeekIndex = newWeekIndex;\r\nlet sequenceNumber = 0;\r\nlet updatedTasks = [];\r\n\r\nwhile (remainingHours > 0) {\r\n  const currentWeek = scheduleWeeks[currentWeekIndex];\r\n  const hoursForThisWeek = Math.min(remainingHours, currentWeek.availableCapacity); // Assume each week has an 'availableCapacity'\r\n  remainingHours -= hoursForThisWeek;\r\n  console.log(currentWeek)\r\n  console.log('hours for this week', hoursForThisWeek)\r\n  console.log('remainig', remainingHours)\r\n\r\n  updatedTasks.push({\r\n    ...item,  // Spread the main item to retain other properties\r\n    sequenceNumber,\r\n    rowKey: item.rowKey + (sequenceNumber > 0 ? `-${sequenceNumber}` : ''),\r\n    weekScheduled: currentWeek.rowKey,\r\n    '$weekScheduled$display': currentWeek.name,\r\n    'headerY': headerY,  // 'headerY' represents the resource\r\n    totalEstimatedHours: hoursForThisWeek\r\n  });\r\n\r\n  sequenceNumber++;\r\n  currentWeekIndex = (currentWeekIndex + 1) % scheduleWeeks.length;  // Move to the next week\r\n}\r\n\r\n// Update the draggableComponents object\r\n// First, clear the current task's entries under the specific week and resource\r\nObject.keys(draggableComponents).forEach(week => {\r\n  Object.keys(draggableComponents[week]).forEach(resource => {\r\n     if(draggableComponents[week] &&draggableComponents[week][resource]) {\r\n      draggableComponents[week][resource] = draggableComponents[week][resource].filter(task => !task.rowKey.startsWith(item.rowKey));\r\n\r\n     }\r\n  })\r\n  // if (draggableComponents[week] && draggableComponents[week][headerY]) {\r\n  //   draggableComponents[week][headerY] = draggableComponents[week][headerY].filter(task => !task.rowKey.startsWith(item.rowKey));\r\n  // }\r\n});\r\n\r\n// Add the updated tasks to the new positions\r\nconsole.log('updated tasks', updatedTasks)\r\nupdatedTasks.forEach(task => {\r\n  const weekName = task['$weekScheduled$display']; // This corresponds to headerX\r\n  const resource = task['headerY']; // This corresponds to headerY\r\n\r\n  console.log(weekName, resource)\r\n\r\n  if (!draggableComponents[weekName]) {\r\n    draggableComponents[weekName] = {}; // Create the week if it doesn't exist\r\n  }\r\n  if (!draggableComponents[weekName][resource]) {\r\n    draggableComponents[weekName][resource] = []; // Create the resource array within the week if it doesn't exist\r\n  }\r\n  draggableComponents[weekName][resource].push(task);\r\n});\r\n\r\nconsole.log('draggable components', draggableComponents)\r\n\r\nreturn draggableComponents;\r\n",
  "reloadOnDrag": false,
  "showLeftHeaderTooltips": false,
  "showLeftHeaderTotals": false,
  "showTopHeaderTooltips": false,
  "showTopHeaderTotals": false,
  "smallTemplate": " \r\n <span\r\n style=\"font-size:14px\"\r\n >\r\n {{ (item.actualProductionPerDay / item.estimatedProductionPerDay * 100).toFixed(0) }}%\r\n </span>",
  "template": "\r\n<div :style=\"`font-size:12px; text-align: left; padding-left: 14px;`\">\r\n  {{item.name}} - {{item.totalEstimatedHours}} hrs\r\n  {{item.$part$display}}\r\n</div>\r\n",
  "titleCol": "name",
  "updateRuleFunctionForCustomLeftHeaders": "",
  "updateRuleFunctionForCustomTopHeaders": "",
  "visibleLanes": [
    "-O9AVPNwxqNYemo-E7zq",
    "-O9AVPOQmiuAidg_pec5",
    "-O9AVPOiSmfyeT5wuL_e",
    "-O9AVPOwj2nw35rIQ-g6"
  ]
}